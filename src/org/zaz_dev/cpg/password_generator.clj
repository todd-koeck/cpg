(ns org.zaz-dev.cpg.password-generator
  (:require (org.zaz-dev.cpg
             [utils :refer :all]))
  (:gen-class))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;
;;;; The password list generated by make-pwds-from-spec
;;;; is a lazy sequence.  It is capable of generating
;;;; very large lists of possible passwords without
;;;; consuming enormous amounts of memory.
;;;;
;;;; The password list produced by load-password-file
;;;; lives in memory.  The entire list is loaded into
;;;; memory at the start of the program.
;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Character sets that can be used on the command line
;; to attempt to brute force guess a password.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def lower-case
  {:desc "All the lower case characters in the English alphabet."
   :chars "abcdefghijklmnopqrstuvwxyz"})

(def upper-case
  {:desc "All the upper case characters in the English alphabet."
   :chars "ABCDEFGHIJKLMNOPQRSTUVWXYZ"})

(def digits
  {:desc "All the Arabic digits."
   :chars "1234567890"})

(def common-special
  {:desc "Punctuation and other common characters not found in the other lists."
   :chars "!\"#%&'()*+,-./:;<=>?@[\\]^_`{|}~$ "})

(def all-chars
  {:desc "These are all the unique chars found in several
  publically available password files found in the wild
  on the Internet."
   :chars "ōàˌ !\"#$%ə&'(ñ)*+,-./€0ù123456789:;<=>?@ABCDEFGHIJKLMNOPQRST¡U★V£WĝXYZ§[\\]^_`abc°defghijklmnopqrstuvwxyz{|}~"})

(def char-sets {:lower-case lower-case
                :upper-case upper-case
                :digits digits
                :common-special common-special
                :all-chars all-chars})

(defn make-pwds
  "Given, isq,  an input sequence of characters or a string, produce a lazy
  sequence of strings for all permutations of the input sequence.

  char-cnt determines how many characters will be in the passwords."

  ;; Arity 1, the character sequence.
  ([isq] (make-pwds isq 1))

  ;; Arity 3, the character sequence and min and max length.
  ([isq min-length max-length]
   (loop [n min-length
          lzsq (make-pwds isq n)
          n+1 (inc n)]
     (if (>= n max-length)
       lzsq
       (let [mps (make-pwds isq n+1)
             new-count (+ (:count mps) (:count lzsq))
             new-pwds (lazy-cat (:passwords lzsq) (:passwords mps))]
         (recur n+1 {:passwords new-pwds :count new-count} (inc n+1))))))

  ;; Arity 2, the character sequence and the length.
  ([isq char-cnt]
   (let [password-count (int (Math/pow (count isq) char-cnt))]
     (loop [sq1 (seq isq)
            sq2 nil
            n 0
            sq sq1]
       (if (>= n char-cnt)
         {:passwords sq1 :count password-count}
         (if (= n 0)
           (recur (for [c sq1] (str c)) sq (inc n) sq)
           (recur  (for [c sq1 d sq2] (str c d)) sq (inc n) sq)))))))

(defn make-pwds-from-spec
  "Given a map containing a password specification, generate a map
  that contains a lazy sequence, :passwords, and a count, :count,
  of the passwords.

  :chars must be non-nil.

  Either (:min-length > 0 and :max-length > 0 and :max-length > :min-length) or
  :length > 0.

  If the requirements above aren't met, nil is returned."
  [{:keys [chars min-length max-length length]
    :or {chars nil min-length 0 max-length 0 length 0}
    :as pspec}]
  (cond (nil? chars) nil
        (or (> min-length 0) (> max-length 0)) (if (or (= min-length 0) (= max-length 0)
                                                       (> length 0) (>= min-length max-length))
                                                 nil
                                                 (assoc (make-pwds chars min-length max-length)
                                                        :password-spec pspec))
        (> length 0) (assoc (make-pwds chars length)
                            :password-spec pspec)
        :else nil))

(defn parse-password-spec
  "This function parses a string as specified in the doc string for
  parse-password-opt.

  read-string is used to convert the string in password-spec into a
  clojure object.
  
  The function processes that object, building a sequence of characters
  and keeping a record of the length values.  Once it has processed the
  sequence, those values are then used to build a lazy-seq of passwords.

  This sequence is then returned in a map with :count and :passwords
  as the keys."
  [password-spec]
  (let [ps (read-string password-spec)]
    (loop [fst (first ps)
           rst (rest ps)
           minl 0
           maxl 0
           l 0
           chars '()]
      (if (not fst)
        {:chars (sort (set chars))
         :min-length minl
         :max-length maxl
         :length l}
        (cond
          (and (keyword? fst) (fst char-sets)) (recur (first rst) (rest rst) minl maxl l
                                                      (concat chars (:chars (fst char-sets))))
          (= fst :min-length) (let [fst (first rst)
                                    rst (rest rst)
                                    minl fst]
                                (recur (first rst) (rest rst) minl maxl l chars))
          (= fst :max-length) (let [fst (first rst)
                                    rst (rest rst)
                                    maxl fst]
                                (recur (first rst) (rest rst) minl maxl l chars))
          (= fst :length) (let [fst (first rst)
                                rst (rest rst)
                                l fst]
                            (recur (first rst) (rest rst) minl maxl l chars))
          (string? fst) (recur (first rst) (rest rst) minl maxl l (concat chars fst)))))))

(defn load-password-file
  "Load passwords from a file, returning a map with :filename, :count
  and :passwords for keys."
  [filename]
  (let [pwds (file-load-lines filename)
        pwd-count (count pwds)]
    {:filename filename
     :count pwd-count
     :passwords pwds}))
